diff -ru llvm-3.7.1.src.orig/include/llvm/MC/MCMachObjectWriter.h llvm-3.7.1.src/include/llvm/MC/MCMachObjectWriter.h
--- llvm-3.7.1.src.orig/include/llvm/MC/MCMachObjectWriter.h	2016-01-16 01:03:20.437470656 +0100
+++ llvm-3.7.1.src/include/llvm/MC/MCMachObjectWriter.h	2016-01-16 01:56:01.460427757 +0100
@@ -71,6 +71,8 @@
   /// @}
 };
 
+class MCSymbol;
+
 class MachObjectWriter : public MCObjectWriter {
   /// Helper struct for containing some precomputed information on symbols.
   struct MachSymbolData {
@@ -96,7 +98,9 @@
   };
 
   llvm::DenseMap<const MCSection *, std::vector<RelAndSymbol>> Relocations;
-  llvm::DenseMap<const MCSection *, unsigned> IndirectSymBase;
+  typedef std::vector<MCSymbol *> IndirectSymVector;
+  llvm::DenseMap<const MCSection *, IndirectSymVector> IndirectSymTable;
+  llvm::DenseMap<const MCSection *, size_t> IndirectSymBase;
 
   SectionAddrMap SectionAddress;
 
diff -ru llvm-3.7.1.src.orig/lib/MC/MachObjectWriter.cpp llvm-3.7.1.src/lib/MC/MachObjectWriter.cpp
--- llvm-3.7.1.src.orig/lib/MC/MachObjectWriter.cpp	2016-01-16 01:03:20.290803760 +0100
+++ llvm-3.7.1.src/lib/MC/MachObjectWriter.cpp	2016-01-16 02:13:56.289022278 +0100
@@ -30,6 +30,7 @@
 
 void MachObjectWriter::reset() {
   Relocations.clear();
+  IndirectSymTable.clear();
   IndirectSymBase.clear();
   StringTable.clear();
   LocalSymbolData.clear();
@@ -443,9 +444,16 @@
 
 void MachObjectWriter::bindIndirectSymbols(MCAssembler &Asm) {
   // This is the point where 'as' creates actual symbols for indirect symbols
-  // (in the following two passes). It would be easier for us to do this sooner
-  // when we see the attribute, but that makes getting the order in the symbol
-  // table much more complicated than it is worth.
+  // (in the following three passes).
+  // It would be easier for us to do this sooner when we see the attribute,
+  // but that makes getting the order in the symbol table much more
+  // complicated than it is worth.
+  // It is important that the indirect symbols are written per section later.
+  // The MachO format defines an offset into the indirect symbol table for
+  // each section, which identifies the first symbol used by the section.
+  // Mixing the symbols from different sections will produce broken object
+  // files. We take care to collect the symbols used by each section in the
+  // section's own private table.
   //
   // FIXME: Revisit this when the dust settles.
 
@@ -458,39 +466,39 @@
     if (Section.getType() != MachO::S_NON_LAZY_SYMBOL_POINTERS &&
         Section.getType() != MachO::S_LAZY_SYMBOL_POINTERS &&
         Section.getType() != MachO::S_SYMBOL_STUBS) {
-	MCSymbol &Symbol = *it->Symbol;
-	report_fatal_error("indirect symbol '" + Symbol.getName() +
+      MCSymbol &Symbol = *it->Symbol;
+      report_fatal_error("indirect symbol '" + Symbol.getName() +
                            "' not in a symbol pointer or stub section");
     }
   }
 
   // Bind non-lazy symbol pointers first.
-  unsigned IndirectIndex = 0;
   for (MCAssembler::indirect_symbol_iterator it = Asm.indirect_symbol_begin(),
-         ie = Asm.indirect_symbol_end(); it != ie; ++it, ++IndirectIndex) {
+         ie = Asm.indirect_symbol_end(); it != ie; ++it) {
     const MCSectionMachO &Section = cast<MCSectionMachO>(*it->Section);
 
     if (Section.getType() != MachO::S_NON_LAZY_SYMBOL_POINTERS)
       continue;
 
-    // Initialize the section indirect symbol base, if necessary.
-    IndirectSymBase.insert(std::make_pair(it->Section, IndirectIndex));
+    // Store symbol in the table for the section it is used in.
+    auto InsertResult = IndirectSymTable.insert(std::make_pair(it->Section, IndirectSymVector()));
+    InsertResult.first->second.push_back(it->Symbol);
 
     Asm.registerSymbol(*it->Symbol);
   }
 
   // Then lazy symbol pointers and symbol stubs.
-  IndirectIndex = 0;
   for (MCAssembler::indirect_symbol_iterator it = Asm.indirect_symbol_begin(),
-         ie = Asm.indirect_symbol_end(); it != ie; ++it, ++IndirectIndex) {
+         ie = Asm.indirect_symbol_end(); it != ie; ++it) {
     const MCSectionMachO &Section = cast<MCSectionMachO>(*it->Section);
 
     if (Section.getType() != MachO::S_LAZY_SYMBOL_POINTERS &&
         Section.getType() != MachO::S_SYMBOL_STUBS)
       continue;
 
-    // Initialize the section indirect symbol base, if necessary.
-    IndirectSymBase.insert(std::make_pair(it->Section, IndirectIndex));
+    // Store symbol in the table for the section it is used in.
+    auto InsertResult = IndirectSymTable.insert(std::make_pair(it->Section, IndirectSymVector()));
+    InsertResult.first->second.push_back(it->Symbol);
 
     // Set the symbol type to undefined lazy, but only on construction.
     //
@@ -500,6 +508,13 @@
     if (Created)
       cast<MCSymbolMachO>(it->Symbol)->setReferenceTypeUndefinedLazy(true);
   }
+
+  // In the last pass calculate the base index for each section.
+  size_t IndirectBaseIndex = 0;
+  for (const auto &SymTable : IndirectSymTable) {
+    IndirectSymBase.insert(std::make_pair(SymTable.first, IndirectBaseIndex));
+    IndirectBaseIndex += SymTable.second.size();
+  }
 }
 
 /// computeSymbolTable - Compute the symbol table data
@@ -911,26 +926,26 @@
 
   // Write the symbol table data, if used.
   if (NumSymbols) {
-    // Write the indirect symbol entries.
-    for (MCAssembler::const_indirect_symbol_iterator
-           it = Asm.indirect_symbol_begin(),
-           ie = Asm.indirect_symbol_end(); it != ie; ++it) {
-      // Indirect symbols in the non-lazy symbol pointer section have some
-      // special handling.
-      const MCSectionMachO &Section =
-          static_cast<const MCSectionMachO &>(*it->Section);
-      if (Section.getType() == MachO::S_NON_LAZY_SYMBOL_POINTERS) {
-        // If this symbol is defined and internal, mark it as such.
-        if (it->Symbol->isDefined() && !it->Symbol->isExternal()) {
-          uint32_t Flags = MachO::INDIRECT_SYMBOL_LOCAL;
-          if (it->Symbol->isAbsolute())
-            Flags |= MachO::INDIRECT_SYMBOL_ABS;
-          write32(Flags);
-          continue;
+    // Write the indirect symbol entries for each section.
+    for (const auto &SymTable : IndirectSymTable) {
+      const MCSectionMachO &Section = static_cast<const MCSectionMachO &>(*SymTable.first);
+      // Write all symbols for the section into a single, continous table.
+      for (const auto Symbol : SymTable.second) {
+        // Indirect symbols in the non-lazy symbol pointer section have some
+        // special handling.
+        if (Section.getType() == MachO::S_NON_LAZY_SYMBOL_POINTERS) {
+          // If this symbol is defined and internal, mark it as such.
+          if (Symbol->isDefined() && !Symbol->isExternal()) {
+            uint32_t Flags = MachO::INDIRECT_SYMBOL_LOCAL;
+            if (Symbol->isAbsolute())
+              Flags |= MachO::INDIRECT_SYMBOL_ABS;
+            write32(Flags);
+            continue;
+          }
         }
-      }
 
-      write32(it->Symbol->getIndex());
+        write32(Symbol->getIndex());
+      }
     }
 
     // FIXME: Check that offsets match computed ones.
